【5-1-切片引用类型本质】
=====================================================================
// 引用类型
package main

import "fmt"

func showAddr(s []int) []int {
	fmt.Printf("s %p %p,len=%-2d,c=%-2d,%v\n", &s, &s[0], len(s), cap(s), s)
	if len(s) > 0 {
		s[0] = 123
	}
	return s
}

func main() {
	//数组是值copy 但是切片Header变化 ，底层数组地址不变
	//slice 切片 底层的数组地址一样
	s1 := []int{10, 20, 30}
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)

	s2 := s1
	fmt.Printf("s2 %p %p,len=%-2d,c=%-2d,%v\n", &s2, &s2[0], len(s2), cap(s2), s2)
	fmt.Printf("-------------------------------------------------------------------\n")

	s3 := showAddr(s1)
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	fmt.Printf("s2 %p %p,len=%-2d,c=%-2d,%v\n", &s2, &s2[0], len(s2), cap(s2), s2)
	fmt.Printf("s3 %p %p,len=%-2d,c=%-2d,%v\n", &s3, &s3[0], len(s3), cap(s3), s3)
	// s1 0xc000008078 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// s2 0xc0000080a8 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// -------------------------------------------------------------------
	// s 0xc0000080f0 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// s1 0xc000008078 0xc000012120,len=3 ,c=3 ,[123 20 30]
	// s2 0xc0000080a8 0xc000012120,len=3 ,c=3 ,[123 20 30]
	// s3 0xc0000080d8 0xc000012120,len=3 ,c=3 ,[123 20 30]

	//这说明，底层数组是同一份，修改切片中的某个已有元素，那么所有切片都能看到。
	
}

[那如果在上面showAddr函数中对切片增加一个元素会怎么样呢?]
package main

import "fmt"

func showAddr(s []int) []int {
	fmt.Printf("s %p %p,len=%-2d,c=%-2d,%v\n", &s, &s[0], len(s), cap(s), s)

	s = append(s, 100, 200)
	return s
}

func main() {
	//数组是值copy 但是切片Header变化 ，底层数组地址不变
	//slice 切片 底层的数组地址一样
	s1 := []int{10, 20, 30}
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)

	s2 := s1
	fmt.Printf("s2 %p %p,len=%-2d,c=%-2d,%v\n", &s2, &s2[0], len(s2), cap(s2), s2)
	fmt.Printf("-------------------------------------------------------------------\n")

	s3 := showAddr(s1)
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	fmt.Printf("s2 %p %p,len=%-2d,c=%-2d,%v\n", &s2, &s2[0], len(s2), cap(s2), s2)
	fmt.Printf("s3 %p %p,len=%-2d,c=%-2d,%v\n", &s3, &s3[0], len(s3), cap(s3), s3)
	fmt.Printf("-------------------------------------------------------------------\n")

	s1 = s3 //Header赋值 指向同一个底层数组
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	fmt.Printf("s3 %p %p,len=%-2d,c=%-2d,%v\n", &s3, &s3[0], len(s3), cap(s3), s3)

	// s1 0xc000008078 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// s2 0xc0000080a8 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// -------------------------------------------------------------------
	// s 0xc0000080f0 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// s1 0xc000008078 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// s2 0xc0000080a8 0xc000012120,len=3 ,c=3 ,[10 20 30]
	// s3 0xc0000080d8 0xc00000e420,len=5 ,c=6 ,[10 20 30 100 200]
	// -------------------------------------------------------------------
	// s1 0xc000008078 0xc00000e420,len=5 ,c=6 ,[10 20 30 100 200]
	// s3 0xc0000080d8 0xc00000e420,len=5 ,c=6 ,[10 20 30 100 200]

	/*
		可以看到showAddr传入s1但是返回的s3已经和s1不共用同一个底层数组了分道扬镳了，
		其实这里还是值拷贝，不过拷贝的是切片的标头值(Header)。标头值内指针也被复制，刚复制完大家指向同一个底层数组罢了。
		但是仅仅知道这些不够，因为一旦操作切片时扩容了，或另一个切片增加元素，那么就不能简单归结为“切片是引用类型
		拷贝了地址”这样简单的话来解释了。要具体问题，具体分析。

		Go语言中全都是值传递，整型、数组这样的类型的值是完全复制，function这样的引用类型也是值拷贝，不过复制的是标头值。
		slice、map、channel、interface.
	*/
}


总结：
	数组：如果想要使用固定内容不可变的 使用数组
	切片：内容可以变，想要使用同一个底层数组地址

【5-2-子切片1】
=====================================================================
子切片
	slice[xx:yyy]切操作，返回一个子切片
	切的动作，是对原切片的利用，对底层数组的利用，最多全部利用(s1ice[:])，或者部分利用，这些都是对同一个底层数组
	得到一个子 切片，共用底层数组
	切片修改 元素的值，共用底层数组的所有切片看起来

切片长度为5
	索引取元素，slice[5] out of index，index不可以>=len(slice)
	切片这里用了长度 
		slice[:5] [0,5) 0 1 2 3 4 去尾
		slice[:4]前包后不包 [0,4) 0 1 2 3
		容量cap，指的是从header中的地址开始向后，还能容纳几个元素 

		start默认为0
		end默认为len(slice)即切片长度
		通过指针确定底层数组从哪里开始共享
		长度：end-start
		容量：底层数组从偏移开始的元素到结尾能容纳几个元素

package main

import (
	"fmt"
)

func main() {
	s1 := []int{10, 30, 50, 70, 90} //容量，长度为5 索引0、1、2、3、4
	for i := 0; i < len(s1); i++ {
		fmt.Printf("%d : addr = %p\n", i, &s1[i])
	}
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1) //len=5 ,c=5
	fmt.Println("-----------------------------------------------------------------")

	//s2和s1共用底层数组 Header地址不一致
	s2 := s1
	fmt.Printf("s2 %p %p,len=%-2d,c=%-2d,%v\n", &s2, &s2[0], len(s2), cap(s2), s2) //len=5 ,c=5
	fmt.Println("-----------------------------------------------------------------")

	//和s1共用底层数组，从头到尾元素都要
	s3 := s1[:]                                                                    //得到一个子切片，切片类型，header的复制
	fmt.Printf("s3 %p %p,len=%-2d,c=%-2d,%v\n", &s3, &s3[0], len(s3), cap(s3), s3) //len=5 ,c=5
	fmt.Println("-----------------------------------------------------------------")

	//掐头，容量、长度都为4，首地址偏移1个元素，共用底层数组
	//索引 1,2,3,4
	s4 := s1[1:]                                                                   //掐头 共用底层数组，但从给定的索引处开始算起，引起长度和容量的变化
	fmt.Printf("s4 %p %p,len=%-2d,c=%-2d,%v\n", &s4, &s4[0], len(s4), cap(s4), s4) //len=4 ,c=4
	fmt.Println("-----------------------------------------------------------------")

	// 掐头去尾，容量为4，长度为3，首地址偏移1个元素，共用底层数组
	//索引 1,2,3
	s5 := s1[1:4]
	fmt.Printf("s5 %p %p,len=%-2d,c=%-2d,%v\n", &s5, &s5[0], len(s5), cap(s5), s5) //len=3 ,c=4
	fmt.Println("-----------------------------------------------------------------")

	// 去尾，容量为5，长度为4，首地址不变，共用底层数组
	s6 := s1[:4]                                                                   //共用底层数组，去尾，s5认为自己还有1个空间村元素，len=4 cap=5
	fmt.Printf("s6 %p %p,len=%-2d,c=%-2d,%v\n", &s6, &s6[0], len(s6), cap(s6), s6) //len=4 ,c=5
	fmt.Println("-----------------------------------------------------------------")

	//首地址偏移1个元素，长度为0，容量为4，共用底层数组
	s7 := s1[1:1]                                                                  //表示&s7 地址指向 &s1[1]
	fmt.Printf("s7 %p,len=%-2d,c=%-2d,%v\n", &s7, len(s7), cap(s7), s7)            //len=0 ,c=4
	s7 = append(s7, 111)                                                           //请问，为s7增加一个元素，s1、s7分别是什么?
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1) //s1 0xc000008078 0xc00000e420,len=5 ,c=5 ,[10 111 50 70 90]
	fmt.Printf("s7 %p %p,len=%-2d,c=%-2d,%v\n", &s7, &s7[0], len(s7), cap(s7), s7) //s7 0xc000008198 0xc00000e428,len=1 ,c=4 ,[111]
	fmt.Println("-----------------------------------------------------------------")

	// 首地址偏移4个元素，长度为0，容量为1，因为最后一个元素没在切片中，共用底层数组
	s8 := s1[4:4]
	fmt.Printf("s8 %p,len=%-2d,c=%-2d,%v\n", &s8, len(s8), cap(s8), s8) //s8 0xc0000081f8,len=0 ,c=1 ,[]
	fmt.Println("-----------------------------------------------------------------")

	//首地址偏移5个元素，长度为0，容量为0，共用底层数组
	s9 := s1[5:5]
	fmt.Printf("s9 %p,len=%-2d,c=%-2d,%v\n", &s9, len(s9), cap(s9), s9)            //s9 0xc000008228,len=0 ,c=0 ,[]
	s9 = append(s9, 11)                                                            //增加元素会怎样，s1、s9分别是什么？
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1) //s1 0xc000008078 0xc00000e420,len=5 ,c=5 ,[10 111 50 70 90]
	fmt.Printf("s9 %p %p,len=%-2d,c=%-2d,%v\n", &s9, &s9[0], len(s9), cap(s9), s9) //s9 0xc000008228 0xc0000181c0,len=1 ,c=1 ,[11]

	// 0 : addr = 0xc00000e420
	// 1 : addr = 0xc00000e428
	// 2 : addr = 0xc00000e430
	// 3 : addr = 0xc00000e438
	// 4 : addr = 0xc00000e440
	// s1 0xc000008078 0xc00000e420,len=5 ,c=5 ,[10 30 50 70 90]
	// -----------------------------------------------------------------
	// 	s2 0xc0000080a8 0xc00000e420,len=5 ,c=5 ,[10 30 50 70 90]
	// 	-----------------------------------------------------------------
	// 	s3 0xc0000080d8 0xc00000e420,len=5 ,c=5 ,[10 30 50 70 90]
	// 	-----------------------------------------------------------------
	// 	s4 0xc000008108 0xc00000e428,len=4 ,c=4 ,[30 50 70 90]
	// 	-----------------------------------------------------------------
	// 	s5 0xc000008138 0xc00000e428,len=3 ,c=4 ,[30 50 70]
	// 	-----------------------------------------------------------------
	// 	s6 0xc000008168 0xc00000e420,len=4 ,c=5 ,[10 30 50 70]
	// 	-----------------------------------------------------------------
	// 	s7 0xc000008198,len=0 ,c=4 ,[]
	// 	s1 0xc000008078 0xc00000e420,len=5 ,c=5 ,[10 111 50 70 90]
	// 	s7 0xc000008198 0xc00000e428,len=1 ,c=4 ,[111]
	// 	-----------------------------------------------------------------
	// 	s8 0xc0000081f8,len=0 ,c=1 ,[]
	// 	-----------------------------------------------------------------
	// 	s9 0xc000008228,len=0 ,c=0 ,[]
	// 	s1 0xc000008078 0xc00000e420,len=5 ,c=5 ,[10 111 50 70 90]
	// 	s9 0xc000008228 0xc0000181c0,len=1 ,c=1 ,[11]

	/*
		可以看出，切这个操作都是从同一个底层数组上取的段，所以子切片和原始切片共用同一个底层数组
			start默认为0，end默认为len(slice)即切片长度
			通过指针确定底层数组从哪里开始共享
			长度为end-start
			容量是底层数组从偏移开始的元素到结尾能容纳几个元素
	*/
}


【5-3-子切片2】
=====================================================================
//数组也可以切片，会生成新的切片

	
package main

import "fmt"

func main() {
	s1 := [5]int{10, 30, 50, 70, 90} //容量，长度为5、索引0，1，2，3，4
	for i := 0; i < len(s1); i++ {
		fmt.Printf("%d : addr = %p\n", i, &s1[i])
	}
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	// s1 0xc00000e420 0xc00000e420,len=5 ,c=5 ,[10 30 50 70 90]
	fmt.Println("-----------------------------------------------------------------")

	s4 := s1[1:] //掐头，容量、长度都为4，首地址偏移1个元素，共用底层数组
	fmt.Printf("s4 %[5]T %[1]p %p,len=%-2d,c=%-2d,%v\n", &s4, &s4[0], len(s4), cap(s4), s4)
	//返回的是切片
	//s4 []int 0xc000008078 0xc00000e428,len=4 ,c=4 ,[30 50 70 90]
	fmt.Println("-----------------------------------------------------------------")

	s4[0] = 100 //s1 s4分别是什么？
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	fmt.Printf("s4 %[5]T %[1]p %p,len=%-2d,c=%-2d,%v\n", &s4, &s4[0], len(s4), cap(s4), s4)
	// s1 0xc00000e420 0xc00000e420,len=5 ,c=5 ,[10 100 50 70 90]
	// s4 []int 0xc000008078 0xc00000e428,len=4 ,c=4 ,[100 50 70 90]
	fmt.Println("-----------------------------------------------------------------")

	s4 = append(s4, 11, 22) //是否会扩容、会怎样
	fmt.Printf("s1 %p %p,len=%-2d,c=%-2d,%v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	fmt.Printf("s4 %[5]T %[1]p %p,len=%-2d,c=%-2d,%v\n", &s4, &s4[0], len(s4), cap(s4), s4)
	// s1 0xc00000e420 0xc00000e420,len=5 ,c=5 ,[10 100 50 70 90]
	// s4 []int 0xc000008078 0xc000010440,len=6 ,c=8 ,[100 50 70 90 11 22]
	fmt.Println("-----------------------------------------------------------------")

	var s2 = [5]int{2, 4, 6, 8, 10}
	var s3 = make([]int, 3, 5) //len 3 cap 5
	for i := 0; i < len(s3); i++ {
		s3[i] = s2[i]
		fmt.Printf("s3 %d : addr = %p\n", i, &s3[i])
	}
	fmt.Printf("s3 %p %p,len=%-2d,c=%-2d,%v\n", &s3, &s3[0], len(s3), cap(s3), s3)
	// s3 0 : addr = 0xc00000e4e0
	// s3 1 : addr = 0xc00000e4e8
	// s3 2 : addr = 0xc00000e4f0
	// s3 0xc0000080d8 0xc00000e4e0,len=3 ,c=5 ,[2 4 6]
}

[总结]
s1:= make([]int,3,5)
	s1[:]   = s1[0:3] len 3,offset 0,cap 5
	s1[1:]  = s1[1:3] len 2,offset 1,cap 4
	s1[3:]  = s1[3:3] len 0,offset 3,cap 2
	s1[4:]    s1[4:3] end-start=-1 错误 缺省len=3
	s1[4:5] = s1[4:5] len 1,offset 4,cap 1
	s1[5:5] = s1[5:5] len 0,offset 5,cap 0
	s1[:6]  = s1[0:6] len 6,offset 0,cap 6 错误
	s1[6:]  = s1[6:3]错误 
	
【5-4-线性数据结构总结】
=====================================================================
线性数据结构总结
	顺序表
		数组、切片、字符串
	链接表
		container/list，链表
	stack栈
		后进先出LIFO
		函数栈
		物理实现:
			顺序表:开辟连续内存空间，append和pop，可以
			链接表:大量数据仅在尾部上增删，链接表合适。链接表找尾部时间复杂度是0(1)
	queue队列:排好队伍，说明是线性的
		队列不能在中间操作
		LIFO:stack
		FIFO:先进先出队列
				message queue(kafka)，不同业务之间使用消息队列，中间件
				物理实现:链接表
		优先队列:
				数据结构，heap堆，小顶堆，逻辑上是一个树

【5-5-字符集原理】
=====================================================================
编码
	A用一个二进制数表示它
	高级语言编程 分类型，把二进制数分为不同的类型(类型的约束)
	A 1
	人类理解的符号，计算机中必须使用二进制数表达这些人类的符号，为了管理、兼容，制定了标准，建立一个整数到字符符号的
	对应关系表，编码表
		整数->人类的符号
		ASCII
			用1个字节表达这些字符
			整数->英语字符和常见符号=-,.[]()
			a 人类的符号，0x61，把0x61数字不能作为整数类型理解，要求按照string类型理解
				查表找到对应的a，去找字体，知道字这个的符号的点阵，点阵在屏幕上打出来
				整数 称为码点code point
			0x00~0x7F最高位没有用，128种状态
			
			128~255 怎么办？剩余128种
				法语、西欧、 200 某符号
				西班牙 200 n~
				俄语
				ISO8859-1，latin-1 西欧字符
				latin-2
				latin-5
				
			一篇论文:西语 论述法语，用什么编码表，才能表示正确?200
				应用一个编码表

	中文
		常用汉字，3K-5K，好几万个符号，信息化？
		整数2个字节 ->中文字符
				兼容ASCII、每个字节只用最高位1，GB2312、GBK 
		
	unicode
		全世界的符号，全部统一起来放在一个表收录，统一编码
		0x00-0x10FFFF 共1114112个码位
		Unicode建立整数(码点)和字符的映射关系	
		至少需要3个字节
		码点大整数 ->人类字符(兼容ascii)，和中文GBK码点不重合
				编码格式
						UTF32 ，4个字节 直接把码点放进来最高字节空着
						UTF16 变长编码格式 0xFFFF使用双字节，把双字节直接放进来，超出就用4字节
						UTF8  变长编码格式，码点 -> 变长字节的1 ~ 6字节序列  
							<=\x007F使用1个字节
							>\x007F且<= \x07FF使用2个字节
							>\x07FF且<= \xFFFF使用3个字节
								汉字块在\x4E00~\x9FFC之间，因此使用3个字节
							>\xFFFF使用4个字节
		
		多字节大小端、大小尾
		0x6d4b
			4b称为endian，尾巴
			字符串是大尾
		0x 整数16进制前缀，某种整型，不能在加引号
			0x61  整数类型，Go无类型字面常量
			'a'
		\x 转译字符
			'\x61' 字符rune，1个字符，int32 4个字节 源代码中人类字面量标识符 0x61
			"\x61" 字符串类型string，1个字节(不考虑Header)
			"a"
		
#Python 
c = "测"
print(ord(c)) #27979 unicode码点
print(hex(ord(c))) #0x6d4b 6d高位4b低位
print(c.encode("gbk")) #b'\xb2\xe2' unicode码点 编码表 os管理 unicode转换到GBK码点
print(c.encode()) #b'\xe6\xb5\x8b' 3个字节 默认UTF-8
#print(a:=c.encode("utf-16"),[hex(b) for b in a])  python3.8+使用
print("\x6d","\x4b") #m K
print('~' * 30) #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
print(int.from_bytes(b'\x6d\x4b',"big")) #27979 大端模式# GO []bytes{0x6d,0x4b}
print(int.from_bytes(b'\x4b\x6d',"little")) #27979 小端模式 



		
package main
import "fmt"
func main() {
	//ACSII ：0x00~0x7F 范围 共128种字符

	fmt.Println("a\x09b\x0ac \x31\x20\x41\x61")
	//\x09 = \t \x0a=\n \x31=1 \x20=1 \x41=A \x61=a
	//a    b
	//c 1 Aa
	fmt.Println('A' > 'a')   //false
	fmt.Println("a" > "A")   //true
	fmt.Println("AA" > "aa") //false
}